<script>

function trace(s) {
	// que fait cette fonction ?
	// équivalent à if (window.console) console.log(s);
	window.console && console.log(s);
}

var compteur = 0; 
var max = 5; 
function debug(s) {
	// affiche un nombre de messages limité par un compteur
	// affiche le compteur si s n'est pas fourni
	// e.g. après 5 affichages, la fonction ne fait plus rien 
	// comment remettre à 0 le compteur ? 
	if (s == undefined) {
		trace("compteur :" + compteur); 
		return; 
	}  
	if (++compteur<=max) trace(s); 
}

// Bonne pratique : Approche TDD 
// "Test Driven Development" 

debug("message");  // affiche "message"
debug("message");  // affiche "message"
debug("message");  // affiche "message"
debug();					 // affiche la valeur du compteur
debug("message");  // affiche "message"
debug("message");  // affiche "message"
debug("message");  // n'affiche plus rien 
debug();					 // affiche la valeur du compteur
// trouver une solution pour remettre à zéro le compteur ?? 
compteur=0;
// DANGER !! la variable est "publique" car globale
// On aimerait la rendre "privée"
// en C, on pourrait utiliser une variable statique
// en JS : on va utiliser une "closure"
// en français : "fermeture" 
// consiste à 'enfermer' l'accès à une variable 
// en gardant une référence vers cette variable 
// dans le scope d'une fonction 
// SOLUTION : créer un nouveau scope 
// i.e. créer une nouvelle fonction 
// TODO : faire debug2() qui fonctionne SANS variable globale 
// Cf. exemple du cours sur les closures
debug("message");  // affiche "message"

// (function(){}) () permet de créer une fonction anonyme 
// et de l'appeler immédiatement 
// on aurait pu nommer la fonction mkDebug()
// et écrire debug2 = mkDebug(); 

debug2 = (function () {
	var compteur_interne=0; 
	var max_interne=5; 
	return function(s, reset) {
		/* 
		if (s=="reset") {
			// merdique car on ne peut plus écrire "reset"
			compteur_interne = 0;
			return; 
		}
		*/
		if (reset != undefined) {
			// On affiche TOUJOURS s 
			trace(s);
			// et on réinitialise le compteur 
			compteur_interne = 0;
			return;
		}
		
		if (s == undefined) {
			trace("compteur :" + compteur_interne); 
			return; 
		}  
		if (++compteur_interne<=max_interne) trace(s);
	}
}) (); 


debug2("message2");  // affiche "message"
debug2("message2");  // affiche "message"
debug2("message2");  // affiche "message"
debug2();					 // affiche la valeur du compteur
debug2("message2");  // affiche "message"
debug2("message2");  // affiche "message"
debug2("message2");  // n'affiche plus rien 
debug2();					 // affiche la valeur du compteur
// trouver une solution pour remettre à zéro le compteur ?? 
compteur_interne = 0; // ne marche plus ! 
// il faut intégrer le mécanisme de réinitialisation
// DANS la fonction qui est SEULE 
// à avoir accès au compteur interne !
debug2("reinitialisation",true);	
debug2();
debug2("message2");  // affiche "message"

// Mieux encore : un objet oDbg offrant les methodes .trace() .reset() ...

oDbg = (function (max_interne) {
	// max_interne est le paramètre formel de la fonction anonyme 
	// => aussi une variable locale
	var compteur_interne=0; // var locale 
	return {
		trace : function(s){
			if (++compteur_interne<=max_interne) trace(s);
		}, 
		reset : function(){compteur_interne=0;},
		getCompteur : function(){return compteur_interne;},
		setCompteur : function(value){compteur_interne = value;},
		getMax : function(){return max_interne;},
		setMax : function(value){max_interne = value;}
	}; 
}) (5); 


function mkoDbg(max_interne) {
	// max_interne est le paramètre formel de la fonction anonyme 
	// => aussi une variable locale
	var compteur_interne=0; // var locale 
	return {
		trace : function(s){
			if (++compteur_interne<=max_interne) trace(s);
		}, 
		reset : function(){compteur_interne=0;},
		getCompteur : function(){return compteur_interne;},
		setCompteur : function(value){compteur_interne = value;},
		getMax : function(){return max_interne;},
		setMax : function(value){max_interne = value;}
	}; 
}

oDg2 =  mkoDbg(5); 
oDg3 =  mkoDbg(2); // à tester...


oDbg.trace("message3");  // affiche "message"
oDbg.trace("message3");  // affiche "message"
oDbg.trace("message3");  // affiche "message"
trace(oDbg.getCompteur());	// affiche la valeur du compteur
oDbg.trace("message3");  // affiche "message"
oDbg.trace("message3");  // affiche "message"
oDbg.trace("message3");  // n'affiche plus rien 
trace(oDbg.getCompteur());	// affiche la valeur du compteur
oDbg.reset();									// remettre à zéro le compteur
trace(oDbg.getCompteur());
trace(oDbg.getMax());
oDbg.setMax(2);
trace(oDbg.getMax());
oDbg.trace("message3");  // affiche "message"
oDbg.trace("message3");  // affiche "message"
oDbg.trace("message3");  // affiche "message"

function show(refOrId,display) {
	// affiche l'élément dont la référence ou l'id est fourni
	// le paramètre display doit valoir block par défaut
}

function hide(refOrId) {
	// cache l'élément dont la référence ou l'id est fourni
}

function html(refOrId, val) {
	// affecte une valeur à l'élément dont la référence ou l'id est fourni; si val n'est pas fourni, on renvoie son contenu
}

function val(refOrId, val) {
	// affecte une valeur à l'élément dont la référence ou l'id est fourni; si val n'est pas fourni, on renvoie son contenu
	// l'élément est un champ de formulaire
	// la fonction doit pouvoir manipuler l'état des champs de type checkbox et radio 
	
}
</script>
